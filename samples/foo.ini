# command line stuff:
# --start: default to "start"
# --param foo bar: in this file, $foo is replaced with "bar"

# pre-defined keys:
# -----------------
# timeout: default 0 (infinite)
# cwd: default pwd
# start_exec: run only once, before any other exec's, but only if there are any exec's
# pre_exec: run before exec, default empty
# exec: default empty -- warn if empty
# post_exec: run after exec, default empty
# end_exec: run only once, after all other exec's, but only if there are any exec's
# success: default "&if(&eq($status, 0), 1, 0)"
# parent: name of a parent section, default empty (error if section does not exist)
# match: a perl regexp, default ".*" -- only meaningful in "overrides" sections
# stop_on_fail: default 0, stops if success evals to 0 and prunes any children

# suffixes to keys:
# -----------------
# <foo>_overrides: section name, default to empty (error if section does not exist)
# can only use one of these two:
#   <foo>_include: take only items in the <foo> list that match this regexp
#   <foo>_exclude: take only items in the <foo> list that do not match this regexp

# predefined params:
# ------------------
# status: set to be the return status of exec

# functions:
# ----------
# &iterate(...varargs...) returns list of each item -- forces expansion of parent
# &uniq(...varargs...) returns list with duplicates removed
# &if($condition, $true, $false) evals $true if $conditional nonzeo, $false otherwise
# &executable(...varage...) returns list of only existing, executable files
# &list(...varags...) returns a simple list
# &glob($pattern) returns list of files matching pattern (shell globbing)
# &regexp($pattern) returns list of files matching pattern (perl globbing)

# &defined($name) returns 1 if param is defined, 0 otherwise
# &ge($left, $right) returns 1 if $left >= $right
# &gt($left, $right) returns 1 if $left > $right
# &le($left, $right) returns 1 if $left <= $right
# &lt($left, $right) returns 1 if $left < $right
# &eq($left, $right) returns 1 if $left == $right
# &ne($left, $right) returns 1 if $left != $right
# &or(...varargs...) returns 1 if any are nonzero
# &and(...varargs...) returns 1 if all are nonzero

# ick we want to fix:
# umbrella.pl --param "np=&iterate('6', '12', '18')"

# how to handle output [files]


[start]
timeout = 0
exec = /bin/true
post_exec_state_success = &list("warnings", "static", "default", "vpath-rel", "vpath-abs")

[warnings]
provides = compile-ompi
cwd = .....
prefix = "$install_base/warnings"
exec = "./configure --prefix=$prefix options_warnings"

[static]
provides = compile-ompi
cwd = .....
prefix = "$install_base/static"
exec = "./configure --prefix=$prefix options_static"

[default]
provides = compile-ompi
cwd = .....
prefix = "$install_base/default"
exec = "./configure --prefix=$prefix options_default"

[vapth-rel]
provides = compile-ompi
cwd = .....
prefix = "$install_base/default"
exec = "./configure --prefix=$prefix options_default"

[vpath-abs]
provides = compile-ompi
cwd = .....
prefix = "$install_base/default"
exec = "./configure --prefix=$prefix options_default"

#----------------------------------------------------------------------

[rm-ompi-src-tree]
requires = compile-ompi
exec = "rm -rf $src_tree"

#----------------------------------------------------------------------

[compile-intel]
requires = rm-ompi-src-tree
exec = <<EOF
@cmd@
CC=@prefix@/mpicc
export CC
cd intel_tests
make ......
EOF
post_exec_state_success = "run-intel"

#----------------------------------------------------------------------

[compile-ibm]
exec = <<EOF
CC=@prefix@/mpicc
export CC
cd ibm_tests
make ......
EOF
post_exec_state_success = "run-ibm"

#----------------------------------------------------------------------

[run-intel]
timeout = 120
cwd = $path_to_intel

start_exec = << EOF
bourne shell script
EOF

pre_exec = <<EOF
bourne shell script
EOF

exec = "$mpi_launcher -np @np@ @params@ $path_to_intel/@tests@"
exec_exclude = "mpirun .* sm,self $path_to_ibm/dynamic/.*[connect|accept|spawn].*"
success = &if(&eq($status, 0), 1, 0)
post_exec = <<EOF
bourne shell script
EOF
end_exec = <<EOF
bourne shell script
EOF

np = $np 
params = &iterate("--mca pls_slurm_priority 0 --mca pls_rsh_priority 100", "--mca pls_slurm_priority 100 --mca pls_rsh_priorty 0") . \
	"--mca btl $btls,self"
tests = &iterate(&uniq(@file_tests@, @c_tests@, @f_tests@))
tests_exclude = "[josh_is_bad|josh_is_the_devil]"
btls = &iterate("tcp", "mvapi", "sm")
btls_overrides = "sm_stuff"

file_tests = &if(&defined("intel_file"), &cat("$path_to_intel/$intel_file"), )
file_tests_overrides = &list("bad_is_good", "topo_tests")

c_tests = &if(&defined("intel_file"), , &executable(&glob("MPI_*_c")))
c_tests_overrides = &list("bad_is_good", "topo_tests")

f_tests = &if(&defined("intel_flie"), , &executable(&glob("MPI_*_f")))
f_tests_overrides = &list("bad_is_good", "topo_tests")

#---------------------------------------------------------------------

[c_tests_only]
parent = start
exec = "mpirun -np @np@ @params@ $path_to_intel/$c_tests"

[f_tests_only]
parent = start
exec = "mpirun -np @np@ @params@ $path_to_intel/$f_tests"

#---------------------------------------------------------------------

[bad_is_good]
match = "[MPI_Abort_.*|MPI_Initialized_.*]"
success = &if(&ne($status, 0), 1, 0)

[topo_tests]
match = "MPI_Group_foo_.*"
exec_if = &ge($np, 6)

[sm_stuff]
match = "sm"
exec_if = &le($np, 2)
